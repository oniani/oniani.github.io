<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <meta name="HandheldFriendly" content="True">
        <meta name="MobileOptimized" content="320">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="referrer" content="no-referrer">

        <meta property="og:title" content="David Oniani's Website"/>
        <meta property="og:image" content="https://www.davidoniani.com/thumbnail.png"/>
        <meta property="og:description" content="David Oniani's Website"/>
        <meta property="og:url" content="www.davidoniani.com"/>

        
          <meta name="description" itemprop="description" content="David Oniani&#x27;s Website">
        

        
          <meta name="keywords" itemprop="keywords" content="Artificial Intelligence, Development, Engineering, Research">
        

        <link rel="stylesheet" href="http:&#x2F;&#x2F;127.0.0.1:1111&#x2F;fonts.css">
        <link rel="stylesheet" href="http:&#x2F;&#x2F;127.0.0.1:1111&#x2F;style.css">

        <title>
    The Essence of Programming - Functional Approach
</title>

        <!-- Global site tag (gtag.js) - Google Analytics -->
        
          <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116458005-1"></script>
          <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'UA-116458005-1');
          </script>
        

        

        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
        
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"
          integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y"
          crossorigin="anonymous"
        />

        <script
          defer
          src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js"
          integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx"
          crossorigin="anonymous"
        ></script>
        <script
          defer
          src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js"
          integrity="sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy"
          crossorigin="anonymous"
        ></script>
        
        <script
          defer
          src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js"
          integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe"
          crossorigin="anonymous"
          onload="renderMathInElement(document.body);"
        ></script>
            <link rel="stylesheet"
        href="http:&#x2F;&#x2F;127.0.0.1:1111&#x2F;site.css"> 
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"
          integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y"
          crossorigin="anonymous"
        />
         
    </head>
    <body>
        
    <div class="wrap">
        <div class="section" id="title">
            
    The Essence of Programming - Functional Approach

        </div>
        <div class="section" id="content">
            
    
        
            
    
    Sun Nov 25, 2018

        
        
            
                &#183; 3804 words
            
        
        
            
            
                &#183; 20 min
            
        
        
        <hr/>
    
    <p>This blogpost is a general overview of a rather underappreciated programming
methodology called functional programming. Throughout the blogpost, I will
occasionally use the purely functional programming language Haskell as well
as an imperative-style programming language Python. There is also a few lines
of C++. I will be assuming the knowledge of basic programming concepts such as
variable assignment, arithmetic operations, conditional statements, functions,
loops, and recursion.</p>
<p>It is important to note that the blogpost is just an introduction to the
paradigms in functional programming and does not cover any of them in great
detail.</p>
<br>
<hr />
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#what-is-functional-programming">What is Functional Programming?</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#classes-vs-functions">Classes VS Functions</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#natural-results">Natural Results</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#math-sets-and-haskell">Math, Sets, and Haskell</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#state-changes-and-functional-programming">State Changes and Functional Programming</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#control-flow">Control Flow</a>
<ul>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#1-functional-languages-are-declarative">1. Functional Languages Are Declarative</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#2-functional-programming-and-lambda-calculus">2. Functional Programming And Lambda Calculus</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#3-getting-rid-of-loops">3. Getting Rid of Loops</a></li>
</ul>
</li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#purely-functional-languages">Purely Functional Languages</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#conclusion">Conclusion</a></li>
<li><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#how-to-get-started-with-functional-programming">How to Get Started with Functional Programming?</a></li>
</ul>
<hr />
<br>
<h3 id="what-is-functional-programming"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#what-is-functional-programming">What is Functional Programming?</a></h3>
<p><img src="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/new-keyboard.png" alt="New keyboard" /></p>
<p>As mentioned above, functional programming is just an approach to programming.
Particularly, it refers to programming using functions, hence the name
<em>functional programming</em>. To better understand what it means for a programming
language to be functional, let's make a short side-by-side comparison of
functional and, wildly popular, imperative style of programming languages and
then discuss the differences in detail.</p>
<table><thead><tr><th align="center">Imperative language</th><th align="center">Functional language</th></tr></thead><tbody>
<tr><td align="center">Classes and/or structures are the first-class objects</td><td align="center">Functions are the first-class objects</td></tr>
<tr><td align="center">State changes are important</td><td align="center">State changes are limited (or non-existent)</td></tr>
<tr><td align="center">The primary control flows include loops, conditionals, and functions</td><td align="center">The primary control flows are function calls and recursion</td></tr>
</tbody></table>
<h3 id="classes-vs-functions"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#classes-vs-functions">Classes VS Functions</a></h3>
<p>The first comparison shows that, generally speaking, in the imperative
languages (<em>Python, Java, Lua, Nim etc.</em>), variables (instances of classes
and/or structures) dominate over all other objects. Thus, imperative paradigm
makes a clear distinction between variables and functions. On the other hand,
in functional programming languages, functions are the first-class citizens
making virtually everything else rank below them.</p>
<p>Imperative programming languages treat variables as data while functions are
generally used just to manipulate variables. When programming in a functional
language, we say that functions are very similar to variables. In fact, we say
that they are no different than variables as they not only manipulate the data,
but also represent the data themselves. Thus, in the functional world, we say
that the piece of code like a function is also data.</p>
<p>I will give you a concise proof of why functions are data. Remember the table
representations of functions you've learned at some point in the elementary
school? That's the proof! Any function can be represented as a table of values.
For instance, consider a function \( f(x) = 2x \). The following will be a
table representation of the function.</p>
<table><thead><tr><th align="center">\( x \)</th><th align="center">\( f(x) \)</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">0</td></tr>
<tr><td align="center">1</td><td align="center">2</td></tr>
<tr><td align="center">2</td><td align="center">4</td></tr>
<tr><td align="center">3</td><td align="center">6</td></tr>
<tr><td align="center">4</td><td align="center">8</td></tr>
<tr><td align="center">5</td><td align="center">10</td></tr>
<tr><td align="center">6</td><td align="center">12</td></tr>
<tr><td align="center">...</td><td align="center">...</td></tr>
</tbody></table>
<p>Looks more like data? That's because it is the data! We have effectively
generated a 2-column table where each of the cells has a certain value.
Reminds of SQL tables or pandas data frames?</p>
<h3 id="natural-results"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#natural-results">Natural Results</a></h3>
<p>Because functions are so important, there are natural results and outcomes
which are shared among most of functional languages.</p>
<p>Let's write a Haskell function to find the factorial of a positive integer.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#616e88;">-- | A function to find the factorial of a positive integer
</span><span style="color:#d8dee9;">factorial x </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> product [</span><span style="color:#b48ead;">1</span><span style="color:#81a1c1;">..</span><span style="color:#d8dee9;">x]  </span><span style="color:#616e88;">-- easy as that
</span></code></pre>
<p>The function builds a list of integers from 1 up to x and then calculates
the product of these elements. This way we effectively get a product
\( 1 \times 2 \times 3 .. \times \ x \) which is the same as \( x! \).
Since we now have a function, we can call it with the actual parameters!</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#d8dee9;">print (factorial </span><span style="color:#b48ead;">1</span><span style="color:#d8dee9;">)  </span><span style="color:#616e88;">-- prints out 1
</span><span style="color:#d8dee9;">print (factorial </span><span style="color:#b48ead;">6</span><span style="color:#d8dee9;">)  </span><span style="color:#616e88;">-- prints out 720
</span><span style="color:#d8dee9;">print (factorial </span><span style="color:#b48ead;">9</span><span style="color:#d8dee9;">)  </span><span style="color:#616e88;">-- prints out 362880
</span></code></pre>
<p>As shown above, something that in imperative languages would require importing
modules, looping, etc. is a single line in Haskell. This is one of the outcomes
of obsession over functions. Most functional languages have a rich pool of
predefined functions that help manipulate data. In the example above, we also
see a very interesting notation. Namely, <code>[1..x]</code> which builds up a list of
integers from 1 up to \( x \) (\( x \) must also be an integer such that
\( x \geq 1 \)). Thus, another outcome is that data structures and
collections can be created very easily, usually just in a single line of code,
leaving more time for the programmer to deal with functions and the logic.
These are some of the reasons why functional languages are so concise.</p>
<h3 id="math-sets-and-haskell"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#math-sets-and-haskell">Math, Sets, and Haskell</a></h3>
<p>Notice that in the factorial function above, I excluded the case when the
function is called with \( 0 \) (\( 0! = 1 \)). It was done on purpose so
that now we are able to add some other notation and explain the whole function
in detail. Below is a better and more complete version of the function.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#616e88;">-- | A function to find the factorial of a number
</span><span style="color:#88c0d0;">factorial </span><span style="color:#81a1c1;">:: Integer -&gt; Integer
</span><span style="color:#d8dee9;">factorial </span><span style="color:#b48ead;">0 </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">1</span><span style="color:#d8dee9;">
factorial x </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> product [</span><span style="color:#b48ead;">1</span><span style="color:#81a1c1;">..</span><span style="color:#d8dee9;">x]
</span></code></pre>
<p><code>::</code> - prompts that it is a function declaration</p>
<p><code>Integer</code> - type that can hold any number no matter how big, up to the limit of
the machine's memory (so yes, this means you never have arithmetic overflows).</p>
<p><code>-&gt;</code> - tells either what is the type of the next formal parameter or what is
the type of the output</p>
<p>Looks similar to something you have seen before? If you have taken any
undergraduate math class, there is a big chance that you've encountered
the following notation:</p>
<p>\[ f : A \rightarrow B : x \mapsto y \]</p>
<p>The notation above describes/defines a simple function that takes an input
from set \( A \) and maps it to the output in the set \( B \).</p>
<p>Here is the complete definition of the factorial function that we saw above:</p>
<p>\[ f : \mathbb{Z}^+\cup {0} \rightarrow \mathbb{Z}^+ : x \mapsto x! \]</p>
<p>Haskell defines in the similar fashion.</p>
<p><code>factorial :: Integer -&gt; Integer</code> says that <code>factorial</code>
is a function that takes an element from the set of integers and maps it to
some other element in the set of integers. As opposed to math, however, Haskell
does not use \( \mapsto \) notation and instead has the statements below it.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#d8dee9;">factorial </span><span style="color:#b48ead;">0 </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">1</span><span style="color:#d8dee9;">
factorial x </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> product [</span><span style="color:#b48ead;">1</span><span style="color:#81a1c1;">..</span><span style="color:#d8dee9;">x]
</span></code></pre>
<p>The code above is equivalent to saying that if the element is 0, map it to 1
and in all other cases, map it to the product from 1 up to the element.</p>
<h3 id="state-changes-and-functional-programming"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#state-changes-and-functional-programming">State Changes and Functional Programming</a></h3>
<p>Functional languages have a limited notion of state and typically, avoid the
shared mutable state at any cost. <strong>Purely</strong> (see <a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#purely-functional-languages">Purely Functional Languages</a>)
functional languages like Haskell, do not have any state at all. Since there
are no changes in state, there are no variables. Instead, functional languages
offer functions and immutable variables.</p>
<p>To make it clear, let's look at two examples below. One is from Python and the
other is from Haskell.</p>
<p>Python example</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#616e88;"># Define a variable &#39;my_number&#39; and assign it to 3
</span><span style="color:#d8dee9;">my_number </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">3

</span><span style="color:#616e88;"># Increment the variable &#39;my_number&#39; by 1 and reassign it to the result
</span><span style="color:#d8dee9;">my_number </span><span style="color:#81a1c1;">+= </span><span style="color:#b48ead;">1

</span><span style="font-style:italic;color:#88c0d0;">print</span><span style="color:#d8dee9;">(my_number)  </span><span style="color:#616e88;"># Prints out 4
</span></code></pre>
<p>Let's repeat the same steps in Haskell.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#d8dee9;">myNumber </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">3    </span><span style="color:#616e88;">-- Define a variable &#39;myNumber&#39; and assign it to 3
</span><span style="color:#d8dee9;">myNumber </span><span style="color:#81a1c1;">+= </span><span style="color:#b48ead;">1   </span><span style="color:#616e88;">-- Haskell gags here (infinite loop)
</span><span style="color:#d8dee9;">
print myNumber  </span><span style="color:#616e88;">-- This statement is not reachable
</span></code></pre>
<p>Looking at the code above, you might have already noticed that Haskell
does not allow us to change the state of the program. Now you might be
wondering how could one increment variables.</p>
<p>Here is a short answer:</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#d8dee9;">myNumber </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">3                  </span><span style="color:#616e88;">-- Define a variable &#39;myNumber&#39; and assign it to 3
</span><span style="color:#d8dee9;">myOtherNumber </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> myNumber </span><span style="color:#81a1c1;">+ </span><span style="color:#b48ead;">1  </span><span style="color:#616e88;">-- Define a variable &#39;myOtherNumber&#39; and assign it to &#39;myNumber&#39;
</span><span style="color:#d8dee9;">myNumber </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> myOtherNumber      </span><span style="color:#616e88;">-- Redefine &#39;myNumber&#39; and set it to &#39;myOtherNumber&#39;
</span><span style="color:#d8dee9;">print myNumber                </span><span style="color:#616e88;">-- Prints out 4
</span></code></pre>
<p><strong>Longer and better answer</strong></p>
<p><img src="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/recurse-shall-we.png" alt="Let's recurse, shall we?" /></p>
<p>You do not really need such increments or decrements in functional programming
languages. You can easily overcome this hindrance through functions and
recursion. Therefore, instead of mutating objects, we use recursion to
gradually get to the target.</p>
<p>Here is the example of how one could translate a well-known accumulator pattern
from Python to Haskell.</p>
<p>Here is a classic Python accumulator pattern.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#616e88;"># An accumulator pattern approach for finding
# the sum of the first 100 positive integers.

</span><span style="color:#d8dee9;">total </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">0
</span><span style="color:#81a1c1;">for </span><span style="color:#d8dee9;">integer </span><span style="color:#81a1c1;">in </span><span style="font-style:italic;color:#88c0d0;">range</span><span style="color:#d8dee9;">(</span><span style="color:#b48ead;">1</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">100</span><span style="color:#d8dee9;">):
    total </span><span style="color:#81a1c1;">+= </span><span style="color:#d8dee9;">integer

</span><span style="font-style:italic;color:#88c0d0;">print</span><span style="color:#d8dee9;">(total)  </span><span style="color:#616e88;"># Prints out 5050
</span></code></pre>
<p>Here is what it looks like in Haskell.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#d8dee9;">accumulator </span><span style="color:#b48ead;">1 </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">1                        </span><span style="color:#616e88;">-- The base case for the recursion
</span><span style="color:#d8dee9;">accumulator x </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> x </span><span style="color:#81a1c1;">+</span><span style="color:#d8dee9;"> accumulator (x </span><span style="color:#81a1c1;">- </span><span style="color:#b48ead;">1</span><span style="color:#d8dee9;">)  </span><span style="color:#616e88;">-- The recursive case
</span><span style="color:#d8dee9;">

main </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> print (accumulator </span><span style="color:#b48ead;">100</span><span style="color:#d8dee9;">)  </span><span style="color:#616e88;">-- Prints out 5050
</span></code></pre>
<p>In the code excerpt above, we did not use any loops. In fact, we could not use
any loops because functional languages do not support loops. Instead, we
defined a function, used the recursion and calculated the sum of the values
through function calls.</p>
<p><em>Side note</em></p>
<p>In this particular case, we do not even need to implement the recursive
accumulator pattern. All we need to do is use the already predefined <code>sum</code>
function and so-called texas range list notation that we have already
seen (<code>[1..x]</code>).</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#d8dee9;">print (sum [</span><span style="color:#b48ead;">1</span><span style="color:#81a1c1;">..</span><span style="color:#b48ead;">100</span><span style="color:#d8dee9;">])  </span><span style="color:#616e88;">-- Prints out 5050
</span></code></pre><h3 id="control-flow"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#control-flow">Control Flow</a></h3>
<p>As we have already seen, there are no for loops or while loops in functional
programming languages and there are good reasons why. Let's list a few of them
and continue our discussion by elaborating on those reasons.</p>
<ol>
<li>Functional languages are declarative.</li>
<li>Most of functional languages are heavily influenced by lambda calculus.</li>
<li>If you were to implement a functional programming language,
you would yourself get rid of loops.</li>
</ol>
<h3 id="1-functional-languages-are-declarative"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#1-functional-languages-are-declarative">1. Functional Languages Are Declarative</a></h3>
<p>For those who are new to the idea of declarative languages, let's first
discuss what it means for a language to be declarative. Here is a simple
definition:</p>
<blockquote>
<p>Declarative programming is a method to abstract away the control flow for
logic required for performing an action, and instead involves stating what
the task or desired outcome is.</p>
</blockquote>
<p>The examples of declarative languages are SQL, Haskell, Prolog etc.</p>
<p><em>Example 1</em>: Consider the SQL querying language. In SQL, one doesn't
describe what how to get the data. One just tells SQL what data is needed,
and SQL engine figures out the best way to get it.</p>
<p><em>Example 2</em>: A better example might be comparing two implementations
of a simple function. Let's implement them in both Python and Haskell.</p>
<p>The function takes a list of integers and returns the sum of odd integers in it.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#81a1c1;">def </span><span style="color:#88c0d0;">odd_sum</span><span style="color:#d8dee9;">(list_of_integers):
    </span><span style="color:#616e88;">&quot;&quot;&quot;Return the sum of all odd integers in the list.&quot;&quot;&quot;
    </span><span style="color:#d8dee9;">total </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">0
    </span><span style="color:#81a1c1;">for </span><span style="color:#d8dee9;">integer </span><span style="color:#81a1c1;">in </span><span style="color:#d8dee9;">list_of_integers:
        </span><span style="color:#81a1c1;">if </span><span style="color:#d8dee9;">integer </span><span style="color:#81a1c1;">% </span><span style="color:#b48ead;">2 </span><span style="color:#81a1c1;">== </span><span style="color:#b48ead;">1</span><span style="color:#d8dee9;">:
            total </span><span style="color:#81a1c1;">+= </span><span style="color:#d8dee9;">integer
    </span><span style="color:#81a1c1;">return </span><span style="color:#d8dee9;">total


</span><span style="font-style:italic;color:#88c0d0;">print</span><span style="color:#d8dee9;">(</span><span style="color:#88c0d0;">odd_sum</span><span style="color:#d8dee9;">([</span><span style="color:#b48ead;">1</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">2</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">3</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">4</span><span style="color:#eceff4;">, </span><span style="color:#b48ead;">5</span><span style="color:#d8dee9;">]))  </span><span style="color:#616e88;"># Prints out 9
</span></code></pre>
<p>Let's do a shallow analysis of the <code>odd_sum</code> function. As seen above, it
starts by declaring a variable <code>total</code> which is initially set to 0. Then,
we iterate over the list and through each iteration, we check if the
integer is odd and if it is, we add it to <code>total</code>. In the end, we return
the <code>total</code> variable.</p>
<p>Now, that we have analyzed the function a bit, notice that in the for
loop, through each iteration, we are giving Python directions when to
add the integer to <code>total</code> (only if it is odd). Thus, <strong>we tell Python what
to do step-by-step</strong>. This is an important characteristic that distinguishes
non-declarative languages from declarative ones.</p>
<p>Let's now look at the Haskell example.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#d8dee9;">oddSum x </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> sum (filter odd x)

main </span><span style="color:#81a1c1;">=</span><span style="color:#d8dee9;"> print (oddSum [</span><span style="color:#b48ead;">1</span><span style="color:#eceff4;">,</span><span style="color:#b48ead;">2</span><span style="color:#eceff4;">,</span><span style="color:#b48ead;">3</span><span style="color:#eceff4;">,</span><span style="color:#b48ead;">4</span><span style="color:#eceff4;">,</span><span style="color:#b48ead;">5</span><span style="color:#d8dee9;">])  </span><span style="color:#616e88;">-- Prints out 9
</span></code></pre>
<p>Notice what we did here. First we defined a function <code>oddSum</code> which takes
a list. Then we used the function <code>filter</code> (happened to be predefined) in
conjunction with another predefined function <code>odd</code> (returns true if the value
is odd an false otherwise) to get the list of odd integers. Finally, we summed
up all the odd integers and got the result.</p>
<p>See the difference? In Python, we used a for loop and through each iteration,
we told Python whether to add the integer it to <code>total</code> or not. In Haskell,
however, we gave a whole list to the function and told it to just remove
all of the even integers from the list and then to sum up the rest (if you
eliminate all the even integers, you are obviously left with all the odd
integers). In other words, in the Haskell example, we do not care how the
functions <code>sum</code> and <code>filter</code> work internally, we only care about the fact that
they do their job - sum up the odd numbers in the list and return the value.</p>
<h3 id="2-functional-programming-and-lambda-calculus"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#2-functional-programming-and-lambda-calculus">2. Functional Programming And Lambda Calculus</a></h3>
<p><img src="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/half-life-lambda.jpg" alt="Half-Life video game series" /></p>
<p>Lambda calculus (also written as (\( \lambda \)-calculus) is a branch of
mathematics which was developed by <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>
in the 1930s. It is a formal system for expressing computation and an alternative
to what's called <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a> which
was introduced by <a href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>.
Turing machines involve loops and other non-declarative approaches (Turing machines
are the inspiration for programming languages like Java, Python, etc).
A few years later, Church and Turing collaboratively wrote a paper which is now
know as the <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">computability thesis</a>
and proved that all the computation that was done using Turing machines could
effectively be done in lambda calculus as well. Hence, simply put, lambda calculus
has the power equivalent to that of Turing machines. Not too long after, people
decided to base programming languages on the ideas in lambda calculus (it was
just as powerful as Turing machines so why not?!). This led to shared characteristics
among functional languages such as lack of loops. Virtually all functional
programming languages have no loops because lambda calculus has no loops.
One could certainly add loops, but they would have been redundant. Instead,
functional languages use a mathematical idea of recursion. This is the part
of the reason why loops are not that appreciated in the functional world.</p>
<h3 id="3-getting-rid-of-loops"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#3-getting-rid-of-loops">3. Getting Rid of Loops</a></h3>
<p><img src="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/loop-recursion_stack.png" alt="For loop VS Runtime stack" /></p>
<p>Despite the fact that sometimes they are very useful, loops must not be a part
of a functional programming language. There are several reasons for this.</p>
<ol>
<li>Loops promote and advocate the idea of &quot;imperativeness&quot; (prompting the language what to do).</li>
<li>Loops usually involve mutating values which is, once again, against functional virtues.</li>
<li>Even if we did not use it imperatively and not mutate values, it would create unnecessary
redundance in a language with the emphasis on recursion (which is just as powerful as a
regular loop!)</li>
</ol>
<h3 id="purely-functional-languages"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#purely-functional-languages">Purely Functional Languages</a></h3>
<p>You might have seen word <em>pure</em> in the beginning of the blogpost where I
mentioned that Haskell is <em>purely</em> functional programming language. However, I
never defined what it means for a functional language to be pure. So let's do
it now!</p>
<p>Those who read the <a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#math-sets-and-haskell">Math, Sets, and Haskell</a>, remember
the math notation for functions? I will use them to take the mystery out of
this concept of being <em>pure</em>!</p>
<p>Suppose we have a function \( f : \mathbb{Z} \rightarrow \mathbb{Z} \). Then
by just looking at the function, we see that it takes an input from a set of
integers and its output is also in the set of integers. In other words,
function \( f \) cannot take inputs like -1.9, 0.2, 12.7 etc. as well as it
cannot give an output like 12.6, 71.9, -9.1 etc. Its input(s) and output(s)
could <strong><u>only</u></strong> be integers.</p>
<p>Now, let's actually make this dull function \( f \) do something. Consider
the function \( f : \mathbb{Z} \rightarrow \mathbb{Z} : x \mapsto 2x \).
Thus, we have a function which does a fairly straightforward thing: takes an
integer and maps it to twice its value (which will also be an integer). Let's
now look at the Haskell implementation of this function</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#616e88;">-- | A function that takes an input and outputs twice its value
</span><span style="color:#88c0d0;">f </span><span style="color:#81a1c1;">:: Integer -&gt; Integer
</span><span style="color:#d8dee9;">f x </span><span style="color:#81a1c1;">= </span><span style="color:#b48ead;">2</span><span style="color:#d8dee9;"> * x
</span></code></pre>
<p>The function above says that the input (corresponds to the <code>Integer</code> before the
arrow) is always an integer and the output (corresponds to the <code>integer</code> after
the arrow) is also an integer. <strong>Hence, we always know what type is the input
and what type is the output.</strong> In fact, we also know that the if we call a
function with say 5, we will always get the same result. Namely, <code>f 5 = 10</code>.
Hence, we got that input(s) and output(s) are always integers and the function
called with same actual parameters always return the same value! This is what
makes Haskell a purely functional language. <strong>At any given point in time, we
always know what is the type of input and what is type of output. Besides,
we know that the function called with the same actual parameter(s), always
returns the same value</strong>. Such functions virtually never produce side effects
since we already know what to expect for a given input. <strong>Such functions are
called pure!</strong></p>
<p>To further demystify this idea, let's look at the following piece of code
from a C++ programming language.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#616e88;">/*
 * An example of a function that is pretending to be pure.
 *
 */

</span><span style="color:#5e81ac;">#include </span><span style="color:#a3be8c;">&lt;iostream&gt;

</span><span style="color:#81a1c1;">using namespace</span><span style="color:#d8dee9;"> std</span><span style="color:#eceff4;">;

</span><span style="color:#81a1c1;">int </span><span style="color:#88c0d0;">not_so_pure_function</span><span style="color:#d8dee9;">(</span><span style="color:#81a1c1;">int </span><span style="color:#d8dee9;">value) {
    </span><span style="color:#81a1c1;">return</span><span style="color:#d8dee9;"> value </span><span style="color:#81a1c1;">+ </span><span style="color:#88c0d0;">rand</span><span style="color:#d8dee9;">() </span><span style="color:#81a1c1;">% </span><span style="color:#b48ead;">3</span><span style="color:#eceff4;">;
</span><span style="color:#d8dee9;">}

</span><span style="color:#81a1c1;">int </span><span style="color:#88c0d0;">main</span><span style="color:#d8dee9;">() {
    cout </span><span style="color:#81a1c1;">&lt;&lt; </span><span style="color:#a3be8c;">&quot;Returns: &quot; </span><span style="color:#81a1c1;">&lt;&lt; </span><span style="color:#88c0d0;">not_so_pure_function</span><span style="color:#d8dee9;">(</span><span style="color:#b48ead;">7</span><span style="color:#d8dee9;">) </span><span style="color:#81a1c1;">&lt;&lt;</span><span style="color:#d8dee9;"> endl</span><span style="color:#eceff4;">;  </span><span style="color:#616e88;">// Prints out 8
</span><span style="color:#d8dee9;">    cout </span><span style="color:#81a1c1;">&lt;&lt; </span><span style="color:#a3be8c;">&quot;Returns: &quot; </span><span style="color:#81a1c1;">&lt;&lt; </span><span style="color:#88c0d0;">not_so_pure_function</span><span style="color:#d8dee9;">(</span><span style="color:#b48ead;">7</span><span style="color:#d8dee9;">) </span><span style="color:#81a1c1;">&lt;&lt;</span><span style="color:#d8dee9;"> endl</span><span style="color:#eceff4;">;  </span><span style="color:#616e88;">// Prints out 8
</span><span style="color:#d8dee9;">    cout </span><span style="color:#81a1c1;">&lt;&lt; </span><span style="color:#a3be8c;">&quot;Returns: &quot; </span><span style="color:#81a1c1;">&lt;&lt; </span><span style="color:#88c0d0;">not_so_pure_function</span><span style="color:#d8dee9;">(</span><span style="color:#b48ead;">7</span><span style="color:#d8dee9;">) </span><span style="color:#81a1c1;">&lt;&lt;</span><span style="color:#d8dee9;"> endl</span><span style="color:#eceff4;">;  </span><span style="color:#616e88;">// Prints out 7
</span><span style="color:#d8dee9;">}
</span></code></pre>
<p>Here, we defined a function that takes an integer input and it seems like the
output is also an integer. We now might be lured into thinking that function
<code>not_so_pure_function</code> gives the same output for the same input, but that is
clearly not the case here (that is why it's called <code>not_so_pure_function</code>).
Let's take a closer look at what the function does. It takes an integer value
and returns the value plus some random number which is 0, 1 or 2. When we first
called the function with the actual parameter 7, we got 8 as an output. The
second time, we got 8 again. The third time however, we got 7. Hence, for the
third time, the output was not the same. Therefore, the function is not pure.</p>
<p>You now might wondering why I could not do the same trick in Haskell. In fact,
I certainly can. However, in Haskell, such function would not have a type <code>Int</code>.
It would have a type <code>IO Int</code>. <code>IO</code> is usually associated with file input / output
and it is reasonable that it is associated with functions that are not always
&quot;truthful&quot; as File I/O could in fact be one of the nastiest experiences for a
programmer. So many things can go wrong! (e.g., writing to a file which was
deleted, reading from a file on a USB which was ejected, writing a file that
was moved to some other directory etc). Thus, when we deal with uncertainty
(which usually comes with side effects), Haskell warns us by using the <code>IO</code>
notation.</p>
<p>Here is how <code>not_so_pure_function</code> could be made <em>pure</em> in Haskell.</p>
<pre style="background-color:#2e3440;">
<code><span style="color:#616e88;">{-
Example of a function that if called with the same argument,
does not always return the same result.
-}

</span><span style="color:#81a1c1;">import </span><span style="color:#d8dee9;">System.Random (</span><span style="color:#88c0d0;">randomRIO</span><span style="color:#d8dee9;">)


</span><span style="color:#88c0d0;">purifiedFunction </span><span style="color:#81a1c1;">:: Int -&gt; IO Int
</span><span style="color:#d8dee9;">purifiedFunction value </span><span style="color:#81a1c1;">= do</span><span style="color:#d8dee9;">
    randomValue </span><span style="color:#81a1c1;">&lt;-</span><span style="color:#d8dee9;"> randomRIO (</span><span style="color:#b48ead;">0</span><span style="color:#eceff4;">,</span><span style="color:#b48ead;">2</span><span style="color:#d8dee9;">)
    return (value </span><span style="color:#81a1c1;">+</span><span style="color:#d8dee9;"> randomValue)


main </span><span style="color:#81a1c1;">= do</span><span style="color:#d8dee9;">
    x </span><span style="color:#81a1c1;">&lt;-</span><span style="color:#d8dee9;"> purifiedFunction </span><span style="color:#b48ead;">7</span><span style="color:#d8dee9;">
    print x                  </span><span style="color:#616e88;">-- Prints out 9
</span><span style="color:#d8dee9;">    x </span><span style="color:#81a1c1;">&lt;-</span><span style="color:#d8dee9;"> purifiedFunction </span><span style="color:#b48ead;">7</span><span style="color:#d8dee9;">
    print x                  </span><span style="color:#616e88;">-- Prints out 7
</span><span style="color:#d8dee9;">    x </span><span style="color:#81a1c1;">&lt;-</span><span style="color:#d8dee9;"> purifiedFunction </span><span style="color:#b48ead;">7</span><span style="color:#d8dee9;">
    print x                  </span><span style="color:#616e88;">-- Prints out 9
</span></code></pre>
<p>Look at the Haskell code above. You can disregard all the notational fluff.
Just look at the return type of the function <code>purifiedFunction</code>. It is <code>IO Int</code>!
In other words, Haskell informs us that the function might have side effects.
This is exactly why Haskell is pure.</p>
<p>Finally, we can have sort of a definition of a pure functional language.</p>
<p><strong><span style="color:RED">NOTE:</span></strong> Pure might mean a completely different
thing in non-functional languages.</p>
<blockquote>
<p>A functional language is pure if and only if the user is informed of all
the side effects in a language or there are no side effects at all.</p>
</blockquote>
<p>Actually, Haskell did not allow random values back in 1990s when its development
was first launched. Because of this, Haskell was considered useless for all
practical purposes. Eventually, developers and the Haskell committee decided
to change the direction of Haskell. In lieu of getting rid of all the side
effects, they decided to control the side effects and created a more &quot;regulated&quot;
programming environment.</p>
<h3 id="conclusion"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#conclusion">Conclusion</a></h3>
<p>Functional programming languages are different from imperative ones. Most of
them are based on ideas in lambda calculus. Functional languages are the proper
subset of declarative languages. There are no loops and recursion is used instead.
Changes in state are non-existent and therefore, all the variables are immutable.
Functional languages have a bunch of predefined functions to make it easy for a
programmer to solve problems. Most of functional languages are also very concise
minimizing the time spent on coding and leaving more time for the logic.
Pure functional languages are the proper subset of functional languages.
Purely functional languages inform the user about the side effects in advance.</p>
<br>
<hr />
<br>
<h3 id="how-to-get-started-with-functional-programming"><a href="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/#how-to-get-started-with-functional-programming">How to Get Started with Functional Programming?</a></h3>
<p><img src="http://127.0.0.1:1111/weblog/the-essence-of-programming-functional-approach/haskell-logo.png" alt="Haskell logo" /></p>
<p>There are a lot of functional languages. You will obviously have to decide
which one to learn first. My recommendation would be learning Haskell.
It is a purely functional programming language which has most of (if not all)
the functional ideas in it. Besides, SPJ (<a href="https://en.wikipedia.org/wiki/Simon_Peyton_Jones">Simon Payton Jones</a>)
dedicates most of his time on extending the language and adding new features
to it. So if there is something new and interesting in the world of functional
programming, Haskell will probably get it (and probably sooner than other
functional or imperative languages).</p>
<p>After learning one functional language, it is fairly easy (&quot;easy&quot; is relative,
but being familiar with one functional language automatically makes you
somewhat familiar with others) to transition to the other. Hence, once you have
a good grasp of functional ideas in Haskell, you can then move to languages
like Clojure, Scheme, F# etc.</p>
<p>To get started, visit the <a href="https://www.haskell.org/documentation">Haskell documentation</a>
page which is full of various educational resources.</p>


        </div>
        
    <div class="section bottom-menu">
        <hr/>
        <p>
            
                
                    <a href="&#x2F;about">about</a>
                    &#183;
                
                    <a href="&#x2F;datasets">datasets</a>
                    &#183;
                
                    <a href="&#x2F;projects">projects</a>
                    &#183;
                
                    <a href="&#x2F;research">research</a>
                    &#183;
                
                    <a href="&#x2F;weblog">weblog</a>
                    &#183;
                
            
            <a href="http:&#x2F;&#x2F;127.0.0.1:1111&#x2F;">
                home
            </a>
        </p>
    </div>

        
    
        <div class="section footer">
            &#9400; 2020 David Oniani 
        </div>
    

    </div>

    <script src="/livereload.js?port=1024&amp;mindelay=10"></script></body>
</html>
